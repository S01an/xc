---
title: Windows认证机制
publish_date: 2024-12-07
---

# **LM Hash**

**LM Hash是LM协议认证的凭证，但是LM采用密码散列形式安全性不好。所以从Windows Vista和Windows Server 2008版本开始，Windows系统默认禁用了LM Hash。**

**LM Hash的产生过程：**

**假设密码为`123456`那么它所对应的LM Hash的产生过程如下：**

**首先对密码进行大写转换：`123456` -> `123456`转换为16进制字符串：`123456` -> `313233343536`密码不足14字节要求用0补全：`313233343536`（6bytes）-> `3132333435360000000000000000`（14bytes）密码分割成两个7个字节长的段：`31323334353600` `00000000000000`分别转换成比特串，若长度不足56bits使用0在左边补齐长度：**

- 首先对密码进行大写转换：`123456` -> `123456`
- 转换为16进制字符串：`123456` -> `313233343536`
- 密码不足14字节要求用0补全：`313233343536`（6bytes）-> `3132333435360000000000000000`（14bytes）
- 密码分割成两个7个字节长的段：`31323334353600` `00000000000000`
- 分别转换成比特串，若长度不足56bits使用0在左边补齐长度：

```basic
31323334353600 -> 00110001001100100011001100110100001101010011011000000000
00000000000000 -> 00000000000000000000000000000000000000000000000000000000

```

**每7bits分为一组，每组末尾加0，再组成一组，转换成16进制：**

- 每7bits分为一组，每组末尾加0，再组成一组，转换成16进制：

```basic
0011000010011000100011000110011001000010101010001101100000000000 -> 40a0d0862298d000
0000000000000000000000000000000000000000000000000000000000000000 -> 0000000000000000

```

**分别作为key对 `KGS!@#$%` 进行DES加密：`44efce164ab921ca` `aad3b435b51404ee`将两组DES加密后的字符串拼接得到最终的32位的十六进制数字串：`44efce164ab921caaad3b435b51404ee`**

- 分别作为key对 `KGS!@#$%` 进行DES加密：`44efce164ab921ca` `aad3b435b51404ee`
- 将两组DES加密后的字符串拼接得到最终的32位的十六进制数字串：`44efce164ab921caaad3b435b51404ee`

**LM加密算法存在的缺陷：**

**LM Hash对密码的长度有限制，只考虑前14个字符，并且会对密码进行大写转换采用的加密方式是分组的DES加密，所以如果密码强度是小于等于7位，那么加密后的结果的后半部分就会是固定的`aad3b435b51404ee`分组加密极大程度降低了密码的复杂度，DES算法强度低**

- LM Hash对密码的长度有限制，只考虑前14个字符，并且会对密码进行大写转换
- 采用的加密方式是分组的DES加密，所以如果密码强度是小于等于7位，那么加密后的结果的后半部分就会是固定的`aad3b435b51404ee`
- 分组加密极大程度降低了密码的复杂度，DES算法强度低

# **NTLM Hash**

**为了解决LM协议认证中固有的安全缺陷，Microsoft于1993年在Windows NT 3.1中引入了NTLM协议。**

**NTLM Hash的产生过程：**

**假设密码为`123456`那么它所对应的NTLM Hash的产生过程如下：**

**首先对密码进行十六进制转换：`123456` -> `313233343536`转换成Unicode格式（每个字节之后添加0x00）：`313233343536` -> `310032003300340035003600`使用MD4摘要算法对Unicode编码数据进行Hash散列，生成32位的十六进制数字串：`32ed87bdb5fdc5e9cba88547376818d4`**

- 首先对密码进行十六进制转换：`123456` -> `313233343536`
- 转换成Unicode格式（每个字节之后添加0x00）：`313233343536` -> `310032003300340035003600`
- 使用MD4摘要算法对Unicode编码数据进行Hash散列，生成32位的十六进制数字串：`32ed87bdb5fdc5e9cba88547376818d4`

```python
import hashlib
import binascii

# 进行Unicode编码
a = "123456".encode("utf-16le")
# 计算MD4散列值
b = hashlib.new("md4", a)
print(binascii.hexlify(b.digest()))
```

```bash
b'32ed87bdb5fdc5e9cba88547376818d4'
```

**对所获取的Unicode字符串进行标准MD4单向哈希，总会固定产生128bits的哈希值。**

**可以看到NTLM Hash明显比LM Hash要安全一些，因为无法根据NTLM Hash判断出原始明文密码的密码强度是否小于等于7位。**

# **Windows本地认证**

**在Windows系统中，登录密码不是直接明文存储，而是会计算成哈希值存储。**

**本地用户的密码被加密存储在 `C:\Windows\System32\config\SAM` 文件中。当用户登录Windows时，系统会自动地读取SAM文件中的哈希值与我们输入的密码（哈希运算后的）进行比对，如果相同则认为认证成功。**

**在Windows内部运行流程大致如下：winlogon.exe -> 接收用户输入 -> lsass.exe -> 认证**

## **LSASS进程**

**LSASS是用户登录验证、密码更改、安全策略管理和其他安全相关操作的核心组件。当用户尝试登录Windows系统时，LSASS进程负责验证用户的凭据。**

![image](https://github.com/user-attachments/assets/7d6f18df-75c5-45a6-aa24-e30f6d873872)


**lsass.exe进程用来处理用户输入的密码，进程将密码计算成NTLM Hash与SAM进行比对，所以lsass.exe会在内存中短暂存储密码信息。**

## **Mimikatz抓取明文密码**

**mimikatz是一个调试神器，最常用的功能就是抓取明文或Hash。**

**上面提到lsass.exe在认证的过程中，会在内存中短暂存储密码信息。所以就可以使用Mimikatz来抓取密码信息。然而从Windows 8.1和Windows Server 2012 R2开始，lsass.exe不再默认存储用户的明文密码，而是以加密形式存储。**

**所以如果尝试使用Mimikatz直接从lsass.exe进程中提取明文密码，密码字段会显示为null。**

![image](https://github.com/user-attachments/assets/4b133e07-2bfe-474c-9ebd-ff140d280853)


**如果仍想使用Mimikatz抓取明文密码，需要修改注册表设置以强制lsass.exe存储明文密码。然后还需要用户重新登录，之后Mimikatz才可能抓取到明文密码。**

**Mimikatz需要管理员权限：**

```cpp
privilege::debug  提升权限
sekurlsa::logonpasswords  抓取密码
```

**需要修改注册表：**

```
reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f
```

**修改注册表之后，需要用户注销或者重启重新登陆之后才会生效。**

**还有其他的方式，比如使用procdump把lsass.exe进程的内存dump下来，然后mimikatz进行读取内容。**

转载：https://www.cnblogs.com/smileleooo/p/18147780
